{% extends "base.html" %}
{% block content %}
<section class="pt-8 sm:pt-12">
  <h1 class="text-2xl font-extrabold text-center tracking-tight title-lower-serif mb-6">
    your trip.
  </h1>

  <!-- Plans grid -->
  <div id="plans-grid" class="grid grid-cols-1 md:grid-cols-2 gap-6"></div>

  <!-- Fallback/raw -->
  <div id="raw-block" class="mt-8 hidden">
    <h2 class="text-sm font-semibold text-slate-600 mb-2">raw output</h2>
    <pre class="bg-white/80 rounded-xl p-4 shadow-sm text-xs overflow-x-auto" id="raw-pre"></pre>
  </div>

  <div class="text-center mt-10">
    <a href="{{ url_for('main.home') }}" class="text-xs text-slate-600 underline">return home</a>
  </div>
</section>

<!-- Safely embed Gemini's string as JSON-string so we can recover it client-side -->
<script type="application/json" id="itinerary-json">{{ payload | tojson }}</script>

{% endblock %}

{% block scripts %}
<script>
(function () {
  const container = document.getElementById('plans-grid');
  const rawNode   = document.getElementById('itinerary-json');
  const rawBlock  = document.getElementById('raw-block');
  const rawPre    = document.getElementById('raw-pre');

  // Pull the city/country user chose (to bias image queries)
  const CITY    = localStorage.getItem('tt.city') || '';
  const COUNTRY = localStorage.getItem('tt.country_name') || '';

  // 1) Recover the raw text Gemini returned (we stored it as a JSON string literal)
  let rawText = "";
  try { rawText = JSON.parse(rawNode.textContent || '""'); } catch { rawText = ""; }

  // 2) Try to extract valid JSON from whatever format (handles ```json fences, extra prose)
  function extractJSON(text) {
    if (!text) return null;
    let t = text.trim();
    const fenced = t.match(/```(?:json)?([\s\S]*?)```/i);
    if (fenced) t = fenced[1].trim();
    const first = t.indexOf('{');
    const last  = t.lastIndexOf('}');
    if (first > -1 && last > -1) t = t.slice(first, last + 1);
    try { return JSON.parse(t); }
    catch {
      try { return JSON.parse(t.replace(/,\s*([}\]])/g, '$1')); }
      catch { return null; }
    }
  }

  const data = extractJSON(rawText);

  // 3) If parsing fails, show raw output
  if (!data || !Array.isArray(data.travel_plans)) {
    rawBlock.classList.remove('hidden');
    rawPre.textContent = rawText || "(no content)";
    return;
  }

  // --- Wikimedia/Wikipedia image lookup (no API key needed) ---
  const mem = new Map(); // in-tab cache
  function cacheGet(k){ const s = sessionStorage.getItem(k); return s ? JSON.parse(s) : null; }
  function cacheSet(k,v){ try { sessionStorage.setItem(k, JSON.stringify(v)); } catch{} }

  async function fetchWikiImage(query) {
    const key = `img:${query.toLowerCase()}`;
    const cached = mem.get(key) || cacheGet(key);
    if (cached) return cached;

    // 1) Search for the best page title
    const searchURL = `https://en.wikipedia.org/w/api.php?action=query&list=search&srsearch=${encodeURIComponent(query)}&srlimit=1&format=json&origin=*`;
    const sRes = await fetch(searchURL);
    const sJson = await sRes.json().catch(()=>({}));
    const title = sJson?.query?.search?.[0]?.title;

    if (!title) { mem.set(key,null); cacheSet(key,null); return null; }

    // 2) Pull page summary (has thumbnail/original) — supports CORS
    const sumURL = `https://en.wikipedia.org/api/rest_v1/page/summary/${encodeURIComponent(title)}`;
    const pRes = await fetch(sumURL);
    const pJson = await pRes.json().catch(()=>({}));

    const url = pJson?.originalimage?.source || pJson?.thumbnail?.source || null;
    const result = url ? { url, title: pJson?.title || title, extract: pJson?.extract || "" } : null;

    mem.set(key, result);
    cacheSet(key, result);
    return result;
  }

  async function findImageForSpot(spot) {
    if (!spot) return null;
    // Try "spot + city + country" first, then "spot + city", then just "spot"
    const tries = [
      [spot, CITY, COUNTRY].filter(Boolean).join(' '),
      [spot, CITY].filter(Boolean).join(' '),
      spot
    ];
    for (const q of tries) {
      const hit = await fetchWikiImage(q);
      if (hit?.url) return hit;
    }
    return null;
  }

  // Small UI helpers
  const el = (tag, cls, text) => {
    const n = document.createElement(tag);
    if (cls) n.className = cls;
    if (text != null) n.textContent = text;
    return n;
  };

  function activityCard(act) {
    const li = el('li','bg-white rounded-lg border overflow-hidden');

    // Image header
    const imgWrap = el('div','relative w-full h-40 bg-slate-100');
    const img = el('img','w-full h-full object-cover absolute inset-0 hidden');
    img.alt = act.spot || 'activity';
    img.loading = 'lazy';
    imgWrap.appendChild(img);

    // Tiny label overlay (time of day)
    if (act.time_of_day) {
      const badge = el('div','absolute top-2 left-2 text-[10px] px-2 py-1 rounded-full bg-white/90 border');
      badge.textContent = act.time_of_day;
      imgWrap.appendChild(badge);
    }

    // Body
    const body = el('div','p-3');
    const heading = el('div','text-sm font-medium', act.spot || '(unspecified spot)');
    const desc = act.description ? el('p','text-sm text-slate-600 mt-1', act.description) : null;

    body.appendChild(heading);
    if (desc) body.appendChild(desc);

    li.appendChild(imgWrap);
    li.appendChild(body);

    // async load image
    (async () => {
      try {
        const hit = await findImageForSpot(act.spot);
        if (hit?.url) {
          img.src = hit.url;
          img.classList.remove('hidden');
        } else {
          // minimal placeholder
          const ph = el('div','absolute inset-0 flex items-center justify-center text-xs text-slate-500');
          ph.textContent = 'no image found';
          imgWrap.appendChild(ph);
        }
      } catch {
        const ph = el('div','absolute inset-0 flex items-center justify-center text-xs text-slate-500');
        ph.textContent = 'no image found';
        imgWrap.appendChild(ph);
      }
    })();

    return li;
  }

  // Render each plan as one column
  data.travel_plans.forEach((plan, idx) => {
    const card = el('div', 'bg-white/80 rounded-2xl p-5 shadow-sm flex flex-col gap-4');

    // Header
    const header = el('div', 'flex items-start justify-between gap-3');
    const titleWrap = el('div');
    titleWrap.appendChild(el('h2','text-lg font-bold', plan.plan_name || `Plan ${idx+1}`));
    if (plan.plan_description) {
      titleWrap.appendChild(el('p','text-sm text-slate-600 mt-1', plan.plan_description));
    }
    header.appendChild(titleWrap);

    const copyBtn = el('button','px-2.5 py-1 text-xs border rounded-lg hover:bg-slate-50');
    copyBtn.textContent = 'copy plan json';
    copyBtn.addEventListener('click', () => {
      const onePlan = JSON.stringify(plan, null, 2);
      navigator.clipboard.writeText(onePlan);
      copyBtn.textContent = 'copied!';
      setTimeout(() => copyBtn.textContent = 'copy plan json', 1200);
    });
    header.appendChild(copyBtn);
    card.appendChild(header);

    // Days
    (plan.daily_plan || []).forEach(day => {
      const dayBox = el('div','rounded-xl border p-4 space-y-3');
      const dayTitle = el('div','flex items-baseline justify-between gap-2');
      const left = el('div','font-semibold', `day ${day.day ?? ''}${day.date ? ` — ${day.date}` : ''}`);
      const theme = day.theme ? el('div','text-xs text-slate-600 italic', day.theme) : null;
      dayTitle.appendChild(left);
      if (theme) dayTitle.appendChild(theme);
      dayBox.appendChild(dayTitle);

      const list = el('ul','grid gap-3'); // stacked; keep it simple
      (day.activities || []).forEach(act => {
        list.appendChild(activityCard(act));
      });
      dayBox.appendChild(list);
      card.appendChild(dayBox);
    });

    container.appendChild(card);
  });
})();
</script>
{% endblock %}
