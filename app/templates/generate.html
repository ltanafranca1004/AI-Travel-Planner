{% extends "base.html" %}
{% block content %}
<div id="navbar" class="fixed top-0 left-0 w-full z-50 bg-[#FFEFEF] backdrop-blur-sm shadow-sm">
  <div class="max-w-7xl mx-auto px-6 py-2 flex items-center gap-2">
    <a href="{{ url_for('main.home') }}" class="flex items-center gap-2 hover:opacity-80 transition-opacity">
      <img src="{{ url_for('static', filename='img/turt-logo.png') }}" alt="Turtle Trips logo" class="h-12 w-auto" />
      <span class="text-xl font-extrabold title-lower-serif tracking-tight">turtle trips.</span>
    </a>
  </div>
  <div class="navbar-underline h-[1px] w-full bg-black/20"></div>
</div>

<style>
/* ✨ simple fade animation */
.fade-in { opacity: 0; transform: translateY(8px); animation: fadeInUp 0.6s ease-out forwards; }
@keyframes fadeInUp { from { opacity: 0; transform: translateY(8px);} to { opacity: 1; transform: translateY(0);} }
/* tiny skeleton for photos */
.skel { background: linear-gradient(90deg,#f3f4f6 25%,#e5e7eb 37%,#f3f4f6 63%); background-size:400% 100%; animation: skel 1.1s ease-in-out infinite; }
@keyframes skel { 0%{background-position:100% 50%} 100%{background-position:0% 50%} }
</style>

<section class="pt-8 sm:pt-12">
  <h2 class="text-3xl mb-2 sm:mb-3 sm:text-4xl font-extrabold text-center tracking-tight title-lower-serif fade-in title-3d">
    <span id="trip-title">your trips!</span>
  </h2>

  <!-- top action bar -->
  <div class="max-w-6xl mx-auto mb-4 flex items-center justify-between fade-in">
    <button id="back-btn" class="hidden px-6 py-3 bg-black text-white rounded-full text-sm font-medium 
      hover:bg-slate-800 transition-all transform hover:scale-105 duration-200">← back</button>
  </div>

  <!-- two column canvas -->
  <div id="view" class="max-w-6xl mx-auto grid grid-cols-1 md:grid-cols-2 gap-6 items-start fade-in">
    <div id="plans-grid" class="grid grid-cols-1 md:grid-cols-2 gap-6 md:col-span-2"></div>

    <div id="map-col" class="hidden opacity-0 transition-opacity duration-500">
      <div class="md:sticky md:top-6">
        <div class="bg-white/80 rounded-2xl p-3 shadow-sm">
          <!-- controls bar for directions -->
          <div id="map-controls" class="flex items-center justify-between px-1 pb-2">
            <div id="day-tabs" class="flex flex-wrap gap-2"></div>
            <select id="travel-mode" class="text-xs border rounded-lg px-2 py-1">
              <option value="WALKING" selected>walking</option>
              <option value="DRIVING">driving</option>
              <option value="BICYCLING">bicycling</option>
            </select>
          </div>
          <div id="map" class="w-full h-[75vh] rounded-xl bg-slate-100"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Fallback/raw -->
  <div id="raw-block" class="mt-8 hidden max-w-6xl mx-auto">
    <h2 class="text-sm font-semibold text-slate-600 mb-2">raw output</h2>
    <pre class="bg-white/80 rounded-xl p-4 shadow-sm text-xs overflow-x-auto" id="raw-pre"></pre>
  </div>

  <!-- Turtle Mascot + speech -->
  <div id="turtle-mascot-wrapper" 
     class="fixed bottom-12 z-50 flex flex-col items-center transition-all duration-300"
     style="left: 3.9rem;">
    <div id="turtle-speech" class="mb-2 max-w-xs px-4 py-2 bg-white/90 backdrop-blur-sm rounded-2xl shadow-sm text-sm font-medium font-montserrat text-slate-800">
      <!-- set by JS -->
    </div>
    <img 
      id="turtle-mascot" 
      src="{{ url_for('static', filename='img/kiss.png') }}" 
      alt="Turtle Mascot" 
      class="h-44 w-auto pointer-events-none"
    />
  </div>

  <script type="application/json" id="itinerary-json">{{ payload | tojson }}</script>
</section>
{% endblock %}

{% block scripts %}
<script>
(function () {
  // Preconnect helps first-image time
  ['https://maps.googleapis.com','https://maps.gstatic.com','https://lh3.googleusercontent.com','https://upload.wikimedia.org']
    .forEach(h => { const l=document.createElement('link'); l.rel='preconnect'; l.href=h; l.crossOrigin=''; document.head.appendChild(l); });

  // Ensure a container element exists for PlacesService (attached to DOM = more reliable)
  const helper = document.createElement('div'); helper.id='places-helper'; helper.style.display='none'; document.body.appendChild(helper);

  const grid      = document.getElementById('plans-grid');
  const mapCol    = document.getElementById('map-col');
  const backBtn   = document.getElementById('back-btn');
  const rawNode   = document.getElementById('itinerary-json');
  const rawBlock  = document.getElementById('raw-block');
  const rawPre    = document.getElementById('raw-pre');
  const CITY      = localStorage.getItem('tt.city') || '';
  const COUNTRY   = localStorage.getItem('tt.country_name') || '';

  // Title
  const titleEl = document.getElementById('trip-title');
  if (CITY) titleEl.textContent = `your trip around ${CITY.toLowerCase()}, ${COUNTRY.toLowerCase()}!`;
  else if (COUNTRY) titleEl.textContent = `your trip around ${COUNTRY.toLowerCase()}!`;
  else titleEl.textContent = 'your trips!';

  // ---- recover AI output ----
  let rawText = "";
  try { rawText = JSON.parse(rawNode.textContent || '""'); } catch { rawText = ""; }
  function extractJSON(text) {
    if (!text) return null;
    let t = text.trim();
    const fenced = t.match(/```(?:json)?([\s\S]*?)```/i);
    if (fenced) t = fenced[1].trim();
    const first = t.indexOf('{'); const last  = t.lastIndexOf('}');
    if (first > -1 && last > -1) t = t.slice(first, last + 1);
    try { return JSON.parse(t); } catch { try { return JSON.parse(t.replace(/,\s*([}\]])/g, '$1')); } catch { return null; } }
  }
  const data = extractJSON(rawText);
  if (!data || !Array.isArray(data.travel_plans)) {
    rawBlock.classList.remove('hidden');
    rawPre.textContent = rawText || "(no content)";
    return;
  }

  // ============================
  // Google Maps loader (with Places)
  // ============================
  const MAPS_KEY = "{{ google_maps_api_key }}";
  let mapsLoaded = !!(window.google && window.google.maps);
  function loadMapsOnce(){
    return new Promise((resolve) => {
      if (mapsLoaded) return resolve();
      if (!MAPS_KEY) return resolve();
      const s = document.createElement('script');
      s.src = `https://maps.googleapis.com/maps/api/js?key=${MAPS_KEY}&libraries=places`;
      s.async = true;
      s.onload = ()=>{ mapsLoaded = true; resolve(); };
      s.onerror= ()=> resolve();
      document.head.appendChild(s);
    });
  }
  loadMapsOnce();

  // ---- session cache helpers ----
  const cacheGet = k => { const s = sessionStorage.getItem(k); return s ? JSON.parse(s) : null; }
  const cacheSet = (k,v) => { try { sessionStorage.setItem(k, JSON.stringify(v)); } catch{} }

  // --- small helper: timeout wrapper ---
  const withTimeout = (p, ms) => Promise.race([
    p, new Promise((_,rej)=> setTimeout(()=> rej(new Error('timeout')), ms))
  ]);

  // =====================================================================
  // City center (bias)
  // =====================================================================
  let CITY_CENTER = null;
  async function getCityCenter(){
    const key = `geo_city:${CITY},${COUNTRY}`.toLowerCase();
    const cached = cacheGet(key);
    if (cached) { CITY_CENTER = cached; return cached; }
    await loadMapsOnce();
    if (!(window.google && google.maps)) return null;
    const geocoder = new google.maps.Geocoder();
    try {
      const { results } = await geocoder.geocode({ address: [CITY, COUNTRY].filter(Boolean).join(', ') });
      if (results && results[0]) {
        const p = results[0].geometry.location;
        CITY_CENTER = { lat: p.lat(), lng: p.lng() };
        cacheSet(key, CITY_CENTER);
        return CITY_CENTER;
      }
    } catch {}
    return null;
  }
  getCityCenter(); // fire & cache early

  // =====================================================================
  // Fallback: Wikipedia image (fast and free)
  // =====================================================================
  async function fetchWikiImage(query) {
    try {
      const sURL = `https://en.wikipedia.org/w/api.php?action=query&list=search&srsearch=${encodeURIComponent(query)}&srlimit=1&format=json&origin=*`;
      const sJson = await withTimeout(fetch(sURL).then(r=>r.json()), 1500).catch(()=>null);
      const title = sJson?.query?.search?.[0]?.title;
      if (!title) return null;
      const sumURL = `https://en.wikipedia.org/api/rest_v1/page/summary/${encodeURIComponent(title)}`;
      const pJson = await withTimeout(fetch(sumURL).then(r=>r.json()), 1500).catch(()=>null);
      const url = pJson?.originalimage?.source || pJson?.thumbnail?.source || null;
      return url ? { url, name: pJson?.title || title, attributions: [] } : null;
    } catch { return null; }
  }

  // =====================================================================
  // Google Places Photos (biased + timeouts) with Wikipedia fallback
  // =====================================================================
  let __placesService = null;
  function getPlacesService() {
    if (__placesService) return __placesService;
    __placesService = new google.maps.places.PlacesService(helper);
    return __placesService;
  }
  function placesTextSearch(query, center) {
    const req = center ? { query, location: center, radius: 30000 } : { query };
    return new Promise((resolve) => {
      getPlacesService().textSearch(req, (results, status) => {
        if (status === google.maps.places.PlacesServiceStatus.OK && Array.isArray(results)) resolve(results);
        else resolve([]);
      });
    });
  }
  function placesFindPlace(query, center){
    const req = center ? { query, fields:['name','photos','place_id'], locationBias: {radius: 30000, center } }
                       : { query, fields:['name','photos','place_id'] };
    return new Promise((resolve) => {
      getPlacesService().findPlaceFromQuery(req, (res, status) => {
        if (status === google.maps.places.PlacesServiceStatus.OK && res?.candidates?.length) resolve(res.candidates);
        else resolve([]);
      });
    });
  }
  function placesGetDetails(placeId) {
    return new Promise((resolve) => {
      getPlacesService().getDetails({ placeId, fields: ['name','photos'] }, (place, status) => {
        if (status === google.maps.places.PlacesServiceStatus.OK && place) resolve(place);
        else resolve(null);
      });
    });
  }

  async function fetchPlacePhotoForQuery(query) {
    await loadMapsOnce();
    const ck = `gphoto:${query.toLowerCase()}`;
    const cached = cacheGet(ck);
    if (cached !== null) return cached;

    const center = CITY_CENTER || await getCityCenter();

    // 1) Biased Text Search
    try {
      const results = await withTimeout(placesTextSearch(query, center), 1800);
      for (const r of results) {
        if (r.photos?.length) {
          const url = r.photos[0].getUrl({ maxWidth: 800, maxHeight: 600 });
          const out = { url, name: r.name || '', attributions: r.photos[0].html_attributions || [] };
          cacheSet(ck, out); return out;
        }
      }
      if (results[0]?.place_id) {
        const det = await withTimeout(placesGetDetails(results[0].place_id), 1200).catch(()=>null);
        if (det?.photos?.length) {
          const url = det.photos[0].getUrl({ maxWidth: 800, maxHeight: 600 });
          const out = { url, name: det.name || '', attributions: det.photos[0].html_attributions || [] };
          cacheSet(ck, out); return out;
        }
      }
    } catch {}

    // 2) Biased FindPlace
    try {
      const cands = await withTimeout(placesFindPlace(query, center), 1800);
      for (const c of cands) {
        if (c.photos?.length) {
          const url = c.photos[0].getUrl({ maxWidth: 800, maxHeight: 600 });
          const out = { url, name: c.name || '', attributions: c.photos[0].html_attributions || [] };
          cacheSet(ck, out); return out;
        }
      }
      if (cands[0]?.place_id) {
        const det = await withTimeout(placesGetDetails(cands[0].place_id), 1200).catch(()=>null);
        if (det?.photos?.length) {
          const url = det.photos[0].getUrl({ maxWidth: 800, maxHeight: 600 });
          const out = { url, name: det.name || '', attributions: det.photos[0].html_attributions || [] };
          cacheSet(ck, out); return out;
        }
      }
    } catch {}

    // 3) Wikipedia fallback
    const wiki = await fetchWikiImage(query);
    cacheSet(ck, wiki || null);
    return wiki;
  }

  // photo lazy queue
  const PHOTO_CONCURRENCY = 6;
  let photoInFlight = 0;
  const photoQueue = [];
  function queuePhoto(job){ photoQueue.push(job); pumpPhotos(); }
  function pumpPhotos(){
    while (photoInFlight < PHOTO_CONCURRENCY && photoQueue.length){
      const { wrapper, spot } = photoQueue.shift();
      photoInFlight++;
      findImageForSpot(spot).then(hit => {
        const img = wrapper.querySelector('img');
        wrapper.classList.remove('skel');
        if (hit?.url) {
          img.src = hit.url;
          img.classList.remove('hidden');
          const tag = document.createElement('div');
          tag.className = 'absolute bottom-1 right-1 text-[10px] bg-black/60 text-white px-1.5 py-0.5 rounded';
          tag.textContent = 'photo';
          wrapper.appendChild(tag);
        } else {
          const ph = document.createElement('div');
          ph.className = 'absolute inset-0 flex items-center justify-center text-xs text-slate-500';
          ph.textContent = 'no image found';
          wrapper.appendChild(ph);
        }
      }).catch(()=>{}).finally(()=>{ photoInFlight--; pumpPhotos(); });
    }
  }

  async function findImageForSpot(spot) {
    if (!spot) return null;
    const tries = [
      [spot, CITY, COUNTRY].filter(Boolean).join(' '),
      [spot, CITY].filter(Boolean).join(' '),
      spot
    ];
    for (const q of tries) {
      const res = await fetchPlacePhotoForQuery(q);
      if (res?.url) return res;
    }
    return null;
  }

  // ---- tiny helpers ----
  const el = (tag, cls, text)=>{ const n=document.createElement(tag); if(cls) n.className=cls; if(text!=null) n.textContent=text; return n; };

  // observe cards so we only fetch photos when the item is near viewport
  const io = new IntersectionObserver((entries)=>{
    entries.forEach(entry=>{
      if (!entry.isIntersecting) return;
      const wrap = entry.target;
      const spot = wrap.dataset.spot || '';
      queuePhoto({ wrapper: wrap, spot });
      io.unobserve(wrap);
    });
  }, { root:null, rootMargin:'800px 0px', threshold:0 });

  function activityItem(act){
    const li = el('li','bg-white rounded-lg border overflow-hidden fade-in');
    const imgWrap = el('div','relative w-full h-40 bg-slate-100 skel');
    imgWrap.dataset.spot = act.spot || '';
    const img = el('img','w-full h-full object-cover absolute inset-0 hidden');
    img.alt = act.spot || 'activity'; img.loading = 'lazy'; img.decoding = 'async'; img.fetchPriority = 'low';
    imgWrap.appendChild(img);

    if (act.time_of_day) {
      const badge = el('div','absolute top-2 left-2 text-[10px] px-2 py-1 rounded-full bg-white/90 border');
      badge.textContent = act.time_of_day; imgWrap.appendChild(badge);
    }
    const body = el('div','p-3');
    body.appendChild(el('div','text-sm font-medium', act.spot || '(unspecified spot)'));
    if (act.description) body.appendChild(el('p','text-sm text-slate-600 mt-1', act.description));
    li.appendChild(imgWrap); li.appendChild(body);

    io.observe(imgWrap); // lazy fetch photo when in view
    return li;
  }

  function renderPlanCard(plan, idx){
    const card = el('div','plan-card relative bg-white/80 rounded-2xl p-5 shadow-sm flex flex-col gap-4 transition transform cursor-pointer hover:-translate-y-0.5 hover:shadow-lg hover:ring-2 hover:ring-emerald-400 opacity-0 translate-y-4 duration-500');
    card.tabIndex = 0;
    requestAnimationFrame(() => { card.classList.remove('opacity-0', 'translate-y-4'); });

    // header (no actions, no copy button)
    const header = el('div','pr-0');
    const titleWrap = el('div');
    titleWrap.appendChild(el('h2','text-lg font-bold', plan.plan_name || `Plan ${idx+1}`));
    if (plan.plan_description) titleWrap.appendChild(el('p','text-sm text-slate-600 mt-1', plan.plan_description));
    header.appendChild(titleWrap);

    const headWrap = el('div','relative');
    headWrap.appendChild(header);
    card.appendChild(headWrap);

    // days
    (plan.daily_plan || []).forEach(day => {
      const box = el('div','rounded-xl border p-4 space-y-3');
      const top = el('div','flex items-baseline justify-between gap-2');
      const left= el('div','font-semibold', `day ${day.day ?? ''}${day.date ? ` — ${day.date}` : ''}`);
      const theme = day.theme ? el('div','text-xs text-slate-600 italic', day.theme) : null;
      top.appendChild(left); if (theme) top.appendChild(theme);
      box.appendChild(top);

      const list = el('ul','grid gap-3');
      (day.activities || []).forEach(a => list.appendChild(activityItem(a)));
      box.appendChild(list);
      card.appendChild(box);
    });

    card.addEventListener('click', () => choosePlan(idx, card, plan));
    card.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); choosePlan(idx, card, plan); } });

    return card;
  }

  // initial render
  data.travel_plans.forEach((p,i)=> grid.appendChild(renderPlanCard(p,i)));

  // ---- selection mode + sticky sync ----
  let chosenIndex = null;
  let heightObserver = null;
  let heightAdjust = null;

  function enableStickySync(card){
    const adjust = () => { mapCol.style.minHeight = card.getBoundingClientRect().height + 'px'; };
    heightAdjust = adjust;
    try { heightObserver?.disconnect(); heightObserver = new ResizeObserver(adjust); heightObserver.observe(card); } catch {}
    adjust(); window.addEventListener('resize', adjust);
  }
  function disableStickySync(){
    try { heightObserver?.disconnect(); } catch {}
    heightObserver = null;
    if (heightAdjust) window.removeEventListener('resize', heightAdjust);
    heightAdjust = null; mapCol.style.minHeight = '';
  }

  function choosePlan(idx, card, plan){
    if (chosenIndex !== null) return;
    chosenIndex = idx;

    const allCards = Array.from(grid.children);
    allCards.forEach(c=>{
      if (c !== card) { c.classList.add('opacity-0','pointer-events-none','transition-opacity','duration-300'); setTimeout(()=> c.classList.add('hidden'), 300); }
      else { c.classList.add('ring-1','ring-emerald-200'); }
    });

    grid.classList.remove('md:col-span-2','md:grid-cols-2');
    grid.classList.add('md:col-span-1','md:grid-cols-1');
    mapCol.classList.remove('hidden');
    requestAnimationFrame(() => { mapCol.classList.remove('opacity-0'); });

    backBtn.classList.remove('hidden');
    grid.innerHTML = '';
    card.classList.remove('hidden','opacity-0','pointer-events-none');
    grid.appendChild(card);

    enableStickySync(card);
    initMapForPlan(plan);
    window.scrollTo({ top: 0, behavior: 'smooth' });
  }

  backBtn.addEventListener('click', resetView);
  function resetView(){
    chosenIndex = null;
    disableStickySync();
    mapCol.classList.add('hidden');
    mapCol.classList.remove('md:block');
    backBtn.classList.add('hidden');
    grid.innerHTML = '';
    grid.classList.remove('md:col-span-1','md:grid-cols-1');
    grid.classList.add('md:col-span-2','md:grid-cols-2');
    data.travel_plans.forEach((p,i)=> grid.appendChild(renderPlanCard(p,i)));
    window.scrollTo({ top: 0, behavior: 'smooth' });
  }

  // ---- mascot quips + footer avoidance
  document.addEventListener('DOMContentLoaded', () => {
    const mascotWrapper = document.getElementById('turtle-mascot-wrapper');
    const speechEl = document.getElementById('turtle-speech');
    const footer = document.querySelector('footer');

    const phrases = [
      "sea-ze the day!","turtley excellent!","fin-tastic picks!",
      "shell yeah!","you're on the right shell!","these plans are turtley rad!"
    ];
    speechEl.textContent = phrases[Math.floor(Math.random() * phrases.length)];

    window.addEventListener('scroll', () => {
      if (!mascotWrapper || !footer) return;
      const footerRect = footer.getBoundingClientRect();
      const windowHeight = window.innerHeight;
      const overlap = windowHeight - footerRect.top;
      mascotWrapper.style.bottom = overlap > 0 ? `${overlap + 24}px` : '3rem';
    });
  });

  // ===========================
  // Map with DAY ROUTES feature
  // ===========================
  const TIME_ORDER = { morning:1, lunch:2, afternoon:3, evening:4, night:5 };
  const timeRank = t => TIME_ORDER[(t || '').toLowerCase()] ?? 99;

  async function initMapForPlan(plan){
    await loadMapsOnce();
    const mapDiv = document.getElementById('map');
    mapDiv.innerHTML = '';

    if (!(window.google && google.maps)) {
      const txt = document.createElement('div');
      txt.className = 'p-4 text-sm text-slate-600';
      txt.textContent = 'Map unavailable (missing or invalid Google Maps API key).';
      mapDiv.appendChild(txt);
      return;
    }

    const map = new google.maps.Map(mapDiv, {
      center: { lat: 0, lng: 0 }, zoom: 2,
      mapTypeControl: false, streetViewControl: false, fullscreenControl: false
    });

    const geocoder = new google.maps.Geocoder();
    const directionsService = new google.maps.DirectionsService();
    let renderers = [];
    let markers = [];

    const days = (plan.daily_plan || []).map(d => ({
      day: d.day, date: d.date, theme: d.theme,
      activities: (d.activities || []).slice().sort((a,b) => timeRank(a.time_of_day) - timeRank(b.time_of_day))
    }));

    // geocode helper (with cache)
    async function geocodeQuery(q){
      const ck = `geo:${q.toLowerCase()}`; const cached = cacheGet(ck);
      if (cached) return cached;
      try {
        const { results } = await geocoder.geocode({ address: q });
        if (results && results[0]) {
          const p = results[0].geometry.location;
          const loc = { lat: p.lat(), lng: p.lng() };
          cacheSet(ck, loc);
          return loc;
        }
      } catch {}
      return null;
    }
    async function geocodeActivity(act){
      const queries = [
        [act.spot, CITY, COUNTRY].filter(Boolean).join(', '),
        [act.spot, CITY].filter(Boolean).join(', '),
        act.spot
      ];
      for (const q of queries) {
        const loc = await geocodeQuery(q);
        if (loc) return loc;
      }
      return null;
    }

    // precompute coords (sequentially to be gentle)
    for (const d of days) {
      for (const a of d.activities) a._loc = await geocodeActivity(a);
    }

    // UI: day tabs + mode
    const tabsWrap = document.getElementById('day-tabs');
    const modeSel  = document.getElementById('travel-mode');
    tabsWrap.innerHTML = '';
    days.forEach((d, i) => {
      const btn = document.createElement('button');
      btn.className = 'px-2.5 py-1 text-xs rounded-full border hover:bg-slate-50';
      btn.textContent = d.date ? `day ${d.day} — ${d.date}` : `day ${d.day}`;
      btn.dataset.index = i;
      tabsWrap.appendChild(btn);
    });

    function clearMap() {
      renderers.forEach(r => r.setMap(null)); renderers = [];
      markers.forEach(m => m.setMap(null));  markers = [];
    }
    function addNumberedMarker(latLng, label, title) {
      const marker = new google.maps.Marker({
        position: latLng, map, title: title || '',
        label: { text: String(label), fontSize: '12px', fontWeight: '700' }
      });
      markers.push(marker);
    }
    function fitBoundsForCoords(coords){
      if (!coords.length) return;
      const b = new google.maps.LatLngBounds();
      coords.forEach(c => b.extend(c));
      map.fitBounds(b); if (map.getZoom() > 15) map.setZoom(15);
    }
    function drawMarkersOnly(ordered){
      let n = 1;
      const coords = [];
      ordered.forEach(a => { addNumberedMarker(a._loc, n++, a.spot); coords.push(a._loc); });
      fitBoundsForCoords(coords);
    }

    function drawDay(index){
      clearMap();
      const d = days[index]; if (!d) return;

      const ordered = d.activities.filter(a => !!a._loc);
      if (!ordered.length) return;
      if (ordered.length === 1) { drawMarkersOnly(ordered); return; }

      const origin = ordered[0]._loc;
      const destination = ordered[ordered.length - 1]._loc;
      const waypoints = ordered.slice(1, -1).map(a => ({ location: a._loc }));
      const SUPPORTED = ['WALKING','DRIVING','BICYCLING'];
      const pick = SUPPORTED.includes(modeSel.value) ? modeSel.value : 'WALKING';
      const travelMode = google.maps.TravelMode[pick];

      directionsService.route(
        { origin, destination, waypoints, optimizeWaypoints: false, travelMode },
        (res, status) => {
          if (status !== 'OK' || !res) { drawMarkersOnly(ordered); return; }

          const color = ['#10b981','#3b82f6','#ef4444','#f59e0b','#8b5cf6','#14b8a6'][index % 6];
          const renderer = new google.maps.DirectionsRenderer({
            map, directions: res, suppressMarkers: true, preserveViewport: false,
            polylineOptions: { strokeColor: color, strokeWeight: 5, strokeOpacity: 0.95 }
          });
          renderers.push(renderer);

          let labelNo = 1;
          for (let i = 0; i < ordered.length; i++) {
            addNumberedMarker(ordered[i]._loc, labelNo++, ordered[i].spot);
          }
          fitBoundsForCoords(ordered.map(a => a._loc));
        }
      );
    }

    // default day 1 active
    const first = tabsWrap.querySelector('button[data-index="0"]');
    if (first) first.classList.add('bg-black','text-white');
    drawDay(0);

    tabsWrap.addEventListener('click', (e)=>{
      const btn = e.target.closest('button[data-index]');
      if (!btn) return;
      Array.from(tabsWrap.children).forEach(c => c.classList.remove('bg-black','text-white'));
      btn.classList.add('bg-black','text-white');
      drawDay(Number(btn.dataset.index));
    });
    modeSel.addEventListener('change', ()=>{
      const active = tabsWrap.querySelector('button.bg-black') || tabsWrap.querySelector('button[data-index="0"]');
      const idx = Number(active.dataset.index || 0);
      drawDay(idx);
    });
  }
})();
</script>
{% endblock %}
